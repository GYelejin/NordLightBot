#include <Arduino.h>

#define DEBUG true

//-----------------Sensors-------------------------//
#include <NewPing.h>
// Maximum distance we want to ping for (in centimeters).
// Maximum sensor distance is rated at 400-500cm.
#define MAX_DISTANCE 500

// Left Sensor Pins
#define TRIGGER_PIN_LEFT 8
#define ECHO_PIN_LEFT 9

// Right Sensor Pins
#define TRIGGER_PIN_RIGHT 12
#define ECHO_PIN_RIGHT 13

// Front Sensor Pins
#define TRIGGER_PIN_FRONT 11
#define ECHO_PIN_FRONT 10

NewPing sonarLeft(TRIGGER_PIN_LEFT, ECHO_PIN_LEFT, MAX_DISTANCE); // NewPing setup of pins and maximum distance.
NewPing sonarRight(TRIGGER_PIN_RIGHT, ECHO_PIN_RIGHT, MAX_DISTANCE);
NewPing sonarFront(TRIGGER_PIN_FRONT, ECHO_PIN_FRONT, MAX_DISTANCE);

int leftSensor, rightSensor, frontSensor;

#define LEFT_LINE_PIN 2  // Left Line Sendor pin
#define RIGHT_LINE_PIN 3 // Right Line Sensor pin

bool leftline, rightline;

const int wall_threshold = 30;
const int front_threshold = 17;

bool frontwall, leftwall, rightwall;

#include "GyverFilters.h"

GMedian3<int> sonarLeftFilter, sonarRightFilter, sonarFrontFilter;
//-----------------End 0f Sensors-------------------------//

//-------------------------Motor---------------------//
#include <GyverMotor.h>

#define DIR_LEFT 7
#define SPEED_LEFT 6
#define DIR_RIGHT 4
#define SPEED_RIGHT 5

#define SPEED 100

GMotor leftmotor(DRIVER2WIRE, DIR_LEFT, SPEED_LEFT, LOW);
GMotor rightmotor(DRIVER2WIRE, DIR_RIGHT, SPEED_RIGHT, LOW);

int leftmotorspeed, rightmotorspeed;
//--------------------------End of Motor--------------//

//-------------------------LCD---------------------//
#include <Wire.h>
#include <LiquidCrystal_I2C.h>

LiquidCrystal_I2C lcd(0x27, 16, 2);

#include <TimerMs.h>
// настройка (период, мс), (не запущен/запущен), (период/таймер)
TimerMs loading_tmr(3500, false, 0);
TimerMs move_tmr(500, false, 0);
int count_of_dots = 0;
int count_of_zero = 0;
//---------------------End of LCD------------------//

//--------------------Serial----------------------//
#include <AsyncStream.h>
AsyncStream<255> serial(&Serial, ';');

//-----------------End of Serial------------------//

//-------------------OS Setup---------------------//
#include <GyverOS.h>
GyverOS<3> OS;

#define LCD_TASK 0
#define MOVEMENT_TASK 1
#define SERIAL_MONITOR_TASK 2
//---------------End of OS Setup------------------//

//-------------------------PID Setup----------------------//
const float kP = 0.7;
const float kI = 0.4;
const float kD = 0.5;
const int offset = 20;
float oldErrorP, totalError;
float errorP, errorI, errorD;
//---------------------End of PID Setup------------------//

bool move_state = true; // Переменная отвечает за активный режим

//------------------------Debug---------------------//
String alldata() // Упаковывает  данные для отправки по UART
{
  return "\n" + String(leftSensor) + "," + String(rightSensor) + "," + String(frontSensor) + "," + String(errorP) + "," + String(errorI) + "," + String(errorD) + "," + String(totalError) + "," + String(leftmotorspeed) + "," + String(rightmotorspeed) + ";";
}

//-------------------------Motor---------------------//
void SetSpeed(int leftWheelSpeed, int rightWheelSpeed) // Установка скорости на оба мотора
{
  leftmotor.setSpeed(leftWheelSpeed);
  rightmotor.setSpeed(rightWheelSpeed);
}
//----------------------End of Motor-----------------//

//------------------------PID------------------------//
void PID(int mode) // Корректировка траектории на основе ПИД регулятора
{
  switch (mode)
  {
  case 0:
    errorP = leftSensor - offset;
    break;
  case 1:
    errorP = rightSensor - offset;
    break;
  case 2:
    errorP = leftSensor - rightSensor - offset;
    break;
  case 3:
    errorP = leftSensor - rightSensor + offset;
    break;
  case 4:
     errorP = leftSensor - rightSensor;
    break;
  }
  errorP = errorP > 255 ? 255 : errorP;
  errorI = 0.6 * errorI + errorP;
  errorD = errorP - oldErrorP;
  totalError = kP * errorP + kI * errorI + kD * errorD;
  oldErrorP = errorP;

  switch (mode)
  {
  case 0:
    leftmotorspeed = SPEED - totalError;
    rightmotorspeed = SPEED + totalError;
    break;
  case 1:
    leftmotorspeed = SPEED + totalError;
    rightmotorspeed = SPEED - totalError;
    break;
  case 2:
    leftmotorspeed = SPEED + totalError;
    rightmotorspeed = SPEED - totalError;
    break;
  case 3:
    leftmotorspeed = SPEED - totalError;
    rightmotorspeed = SPEED + totalError;
    break;
  case 4:
    leftmotorspeed = SPEED + totalError;
    rightmotorspeed = SPEED + totalError;
    break;
  }

  SetSpeed(leftmotorspeed, rightmotorspeed);
}

void resetPID()
{
  oldErrorP = 0;
  errorI = 0;
}
//---------------------End of PID--------------------//

void LCD_dot_animation()
{
  if (count_of_dots > 2)
  {
    lcd.setCursor(11, 1);
    lcd.print("   ");
    count_of_dots = 0;
    lcd.setCursor(11, 1);
  }
  else
  {
    lcd.print(".");
    count_of_dots++;
  }
}

// TODO sonar.convert_cm(sonar.ping_median(iterations));
int one_cycle_of_sensor(NewPing sonar, GMedian3<int> filter)
{
  int count_of_calls = 0;
  int Sensor;
  while (count_of_calls < 2)
  {
    int range = sonar.ping_cm();
    if (range == 0)
    {
      Sensor = Sensor;
    }
    else
    {
      Sensor = filter.filtered(range);
    }
    count_of_calls++;
  }

  return Sensor;
}

int one_cycle_of_sensor_median(NewPing sonar, GMedian3<int> filter)
{
  int Sensor = sonar.convert_cm(sonar.ping_median(10));
  if (Sensor == 0)
  {
    SetSpeed(-170, -170);
  }
  return Sensor;
}
//--------------------------Controllers----------------------//
void start_controller()
{
  lcd.init();
  lcd.home();
  lcd.noBlink();
  lcd.backlight();
  lcd.print("Started");

  delay(1000);

  leftmotor.setMode(AUTO);
  rightmotor.setMode(AUTO);
}

void sensor_controller()

{
  leftline = digitalRead(LEFT_LINE_PIN);
  rightline = digitalRead(RIGHT_LINE_PIN);
  leftSensor = one_cycle_of_sensor(sonarLeft, sonarLeftFilter);

  // average distance between old & new readings to make the change smoother
  rightSensor = one_cycle_of_sensor(sonarRight, sonarRightFilter);
  frontSensor = one_cycle_of_sensor(sonarFront, sonarFrontFilter);

  leftwall = leftSensor < wall_threshold;
  if (rightSensor == 0)
    rightwall = false;
  else if (rightSensor < wall_threshold)
    rightwall = true;
  if (frontSensor == 0)
    frontwall = false;
  else if (frontSensor < wall_threshold)
    frontwall = true;
}

void serial_controller()
{
  if (serial.available())
  {
    switch (String(serial.buf).toInt())
    {
    case 0:
      move_state = false;
      break;
    case 1:
      move_state = true;
      OS.start(MOVEMENT_TASK);
      break;
    }
  }
  if (DEBUG)
    Serial.print(alldata());
}

void lcd_controller()
{
  loading_tmr.tick();
  if (!move_state && !loading_tmr.active())
  {
    lcd.clear();
    lcd.home();
    lcd.print("Waiting");
    lcd.setCursor(0, 1);
    lcd.print("for command");
    loading_tmr.resume();
  }
  if (move_state)
  {
    lcd.clear();
    lcd.home();
    if (DEBUG)
    {
      lcd.print(String(leftSensor) + "|" + String(rightSensor) + "|" + String(frontSensor));
      lcd.setCursor(0, 1);
      lcd.print(String(totalError) + "|" + String(leftmotorspeed) + "|" + String(rightmotorspeed));
    }
    if (loading_tmr.active())
    {
      loading_tmr.stop();
      lcd.print("Moving to Target");
    }
  }
}

void movement_controller()
{
  if (leftline || rightline) // Остановка при достижении чекпоинта
  {
    move_state = false;
  }
  else
  {
    if (leftwall && frontwall && !rightwall) // Объезд препятствия впереди
    {
      SetSpeed(170, -170);
    }
    else
    {
      PID(0);
    }
  }
}

void sensor_and_movement_controller()
{
  sensor_controller();
  if (move_state)
    movement_controller();
  else{
    SetSpeed(1,1);
    OS.stop(MOVEMENT_TASK);
  }
   
}
//---------------------End 0f Controllers--------------------//

void setup() // Инициализациия
{
  start_controller();

  // Запуск слушателя UART
  Serial.begin(115200);

  // Присвоение функций обратного вызова
  OS.attach(LCD_TASK, lcd_controller, 500);
  OS.attach(MOVEMENT_TASK, sensor_and_movement_controller, 100);
  OS.attach(SERIAL_MONITOR_TASK, serial_controller, 1000);
  loading_tmr.attach(LCD_dot_animation);
}

void loop()
{
  OS.tick();
}
